// FileSystemKit Core Library
// Chunk Storage Retrieval Protocol
//
// This file defines the protocol for retrieving chunks from storage.
// The protocol is designed to be wrappable/composable using the Decorator pattern.

import Foundation

/// Protocol for retrieving chunks from storage.
///
/// `ChunkStorageRetrieval` defines how chunk data is read and written.
/// This protocol is designed to be **wrappable/composable** using the Decorator pattern,
/// allowing clients to add functionality like compression, caching, encryption, etc.
///
/// ## Overview
///
/// The retrieval protocol provides:
/// - **Read Operations**: Read chunk data from storage
/// - **Write Operations**: Write chunk data to storage
/// - **Existence Checks**: Check if chunks exist
/// - **Deletion**: Delete chunks from storage
///
/// ## Composable Design
///
/// This protocol is designed to be wrapped/decorated. Clients can wrap retrieval
/// implementations to add:
/// - **Compression/Decompression**: Zip/unzip on the fly
/// - **Caching**: In-memory or persistent caching
/// - **Encryption/Decryption**: Transparent encryption
/// - **Transformation/Validation**: Data transformation or validation
/// - **Logging/Monitoring**: Operation logging and metrics
/// - **Any Custom Behavior**: Custom wrappers for specific needs
///
/// ## Usage
///
/// Read chunk data:
/// ```swift
/// let retrieval = FileSystemRetrieval(baseURL: storageURL)
/// let path = organization.storagePath(for: identifier)
///
/// if let data = try await retrieval.readChunk(at: path) {
///     print("Read \(data.count) bytes")
/// }
/// ```
///
/// Write chunk data:
/// ```swift
/// let retrieval = FileSystemRetrieval(baseURL: storageURL)
/// let path = organization.storagePath(for: identifier)
///
/// try await retrieval.writeChunk(
///     data,
///     at: path,
///     metadata: ChunkMetadata(size: data.count)
/// )
/// ```
///
/// Wrap with compression:
/// ```swift
/// let baseRetrieval = FileSystemRetrieval(baseURL: storageURL)
/// let compressedRetrieval = CompressedRetrieval(
///     wrapped: baseRetrieval,
///     algorithm: .zlib
/// )
/// // Data is automatically compressed on write and decompressed on read
/// ```
///
/// Wrap with caching:
/// ```swift
/// let baseRetrieval = FileSystemRetrieval(baseURL: storageURL)
/// let cachedRetrieval = CachedRetrieval(
///     wrapped: baseRetrieval,
///     cache: InMemoryCache()
/// )
/// // Frequently accessed chunks are cached in memory
/// ```
///
/// ## Wrapping Pattern
///
/// Use the Decorator pattern to wrap retrieval implementations:
/// ```swift
/// struct CompressedRetrieval: ChunkStorageRetrieval {
///     let wrapped: ChunkStorageRetrieval
///
///     func readChunk(at path: String) async throws -> Data? {
///         guard let compressedData = try await wrapped.readChunk(at: path) else {
///             return nil
///         }
///         return try compressedData.decompressed(using: .zlib)
///     }
///
///     func writeChunk(_ data: Data, at path: String, metadata: ChunkMetadata?) async throws {
///         let compressedData = try data.compressed(using: .zlib)
///         try await wrapped.writeChunk(compressedData, at: path, metadata: metadata)
///     }
///
///     // Delegate other methods to wrapped retrieval
///     func chunkExists(at path: String) async -> Bool {
///         return await wrapped.chunkExists(at: path)
///     }
///
///     func deleteChunk(at path: String) async throws {
///         try await wrapped.deleteChunk(at: path)
///     }
/// }
/// ```
///
/// ## See Also
///
/// - ``ChunkStorageOrganization`` - Organization protocol
/// - ``ChunkStorage`` - Composed storage protocol
/// - ``FileSystemRetrieval`` - File system retrieval implementation
/// - [Decorator Pattern (Wikipedia)](https://en.wikipedia.org/wiki/Decorator_pattern) - Design pattern for adding behavior
public protocol ChunkStorageRetrieval: Sendable {
    /// Read chunk data from storage.
    ///
    /// Uses the provided path to locate and read the chunk.
    /// The path is generated by a `ChunkStorageOrganization` implementation.
    ///
    /// **Wrapping**: Wrappers can decompress, decrypt, or transform data before returning.
    ///
    /// - Parameter path: Storage path (from organization strategy)
    /// - Returns: Chunk data, or nil if not found
    /// - Throws: Error if read fails
    func readChunk(at path: String) async throws -> Data?
    
    /// Write chunk data to storage.
    ///
    /// Uses the provided path to write the chunk.
    /// The path is generated by a `ChunkStorageOrganization` implementation.
    /// Should create directory structure if needed (for file system backends).
    ///
    /// **Wrapping**: Wrappers can compress, encrypt, or transform data before writing.
    ///
    /// - Parameters:
    ///   - data: Chunk data to write
    ///   - path: Storage path (from organization strategy)
    ///   - metadata: Optional chunk metadata
    /// - Throws: Error if write fails
    func writeChunk(_ data: Data, at path: String, metadata: ChunkMetadata?) async throws
    
    /// Check if chunk exists at path.
    ///
    /// Uses the provided path to check existence.
    /// The path is generated by a `ChunkStorageOrganization` implementation.
    ///
    /// **Wrapping**: Wrappers can check cache first, then delegate to wrapped retrieval.
    ///
    /// - Parameter path: Storage path (from organization strategy)
    /// - Returns: True if chunk exists
    func chunkExists(at path: String) async -> Bool
    
    /// Delete chunk at path.
    ///
    /// Optional - some storage backends may not support deletion.
    ///
    /// **Wrapping**: Wrappers should also clear cache/compressed versions.
    ///
    /// - Parameter path: Storage path (from organization strategy)
    /// - Throws: Error if deletion fails
    func deleteChunk(at path: String) async throws
}

